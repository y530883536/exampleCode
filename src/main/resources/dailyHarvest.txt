11.29
mysql免安装版如果执行的时候提示少了某个MSV之类的dll，去下载一个vcredist.exe安装
如果莫名其妙无法启动服务，那么去看看data是否创建了，如果创建了里面是不是有文件，这两种情况都会让mysql服务无法启动
角色权限：localhost代表只有本机可以连接上数据库，%表示所有机器都可以连上数据库
mysql5.7免安装版，在配置完之后会为root角色自动创建一个随机密码，这个密码在data文件夹里的xxx.err文件里(xxx是随机的，在文件里搜关键字temporary就可以找到密码所在的那一行)
然后在命令行用mysql -hlocalhost -uroot -p命令进入mysql把这个随机密码改掉（注意用-hlocalhost，不要用-h，不然有很大几率不成功）
POJO对象一般和数据库表的属性一一对应，DTO（数据传输对象）就是增加或删除某些列的POJO（假设现在POJO里有一个属性address，但是前端页面不需要显示address这个属性，那么可以传一个没有这个属性的DTO对象给前端）
记住：git和svn一样，都是需要安装的
从git上check下来的项目会看不见project视图，这时把项目里的.idea文件夹删除再重新打开就可以了

11.30
一般公司的项目肯定是会有maven私服的，一些通用模块会放到私服上去，deploy命令就是把代码上传到私服（install是把代码上传到本地仓库，多人共同开发项目一般都是用deploy的，毕竟代码要给别人使用）
nexus做代码仓库私服
通过groupId，ArtifactId和version可以确定一个maven项目，一般groupId的名字会以一些唯一性比较强的名词组成（比如公司域名反写），避免和他人重复
加盐：密码学的知识，系统随机往客户的密码上加一个值（salt值），salt值只有系统知道，然后再进行散列；这样即使黑客知道了密码，由于salt值是不确定的，也很难盗号（这样撞库就没有用了）
sb.deleteCharAt(sb.length()-1)		//去掉最后一个字符

12.2
让debug，versionControl，maven这些窗口常驻的按钮再左下角那个小电脑处
maintainer比developer的权限还要大
APP不像PC端sessionId，所以登陆这方面处理和PC端不太一样
分布式sessionId一般必须借助redis实现，不过运用JWE(JWT)工具可以更加简单地实现这个功能
origin开头表示远程仓库，没有的表示本地仓库

12.3
容器存放的就是对象本身，而不是对象的拷贝，也就是说对象存放进容器之后，对象修改了，容器里的对象也会修改
clear()方法清空容器里的所有数据（所有存它的容器的数据都会跟着变），它和用"="重新给对象赋值的效果是不一样的，要根据业务需求使用
fastjson可以处理像Map，List这些转成json字符串的需求，非常方便
如果一个表的主键字段不是叫id，那么在@Table注解的时候要在注解里声明主键对应的字段
Ctrl+Shift+U	//将字符串快速大小写
install之后其他项目并不需要reimport

12.4
联表查询在分布式系统中的使用要慎重，因为你不知道哪天关联的那两张表就分开到不同的数据库里面了
在Controller里传递参数时有一个required的参数，如果时true那么你没传这个参数那么就不会进入对应的方法；如果是false你还是会进入对应的方法

12.5
mysql建索引的时候会锁表，在5.6版本之后对建索引时的锁表做了某些优化
对于可变参数的函数，可以直接传一个数组进去
Integer[] ids = new BigInteger[idList.size()];
idList.toArray(ids);												//List转数组
聚合服务要布多点系统
权限管理在网关那边处理，服务是无状态的(也就是请求来就处理，不挑食)

12.6
NIO简单来说就是一条线程处理多个连接
Controller调用Controller或自己旗下的Service，Service调用其他Serivce或自己旗下的Dao
Controller调用Controller有一个非常大的好处，就是参数和返回类型不需要匹配多个，只需要匹配其中一个就可以了
在Controller这一层处理一些简单的权限问题
优先使用Byte.valueOf(String)创建Byte对象而不是用new Byte；当然也可以用(byte)4

12.7
idea一个窗口中增加maven项目，在maven工具栏那里把对应项目的pom文件加进来就可以了，它会自动把项目引入（这对微服务项目尤其便利），而且版本工具能正常使用
删掉窗口中的项目，去项目设置里把那个模块去掉就行了（maven工具栏那里还会存在那个项目的pom文件，只要重启就不见了）
如果在maven中指定了私有仓库，那么在引入其他具有repositories的依赖时，可能会有问题，此时将idea的conf.xml指回默认的配置文件就可以了
工具类为什么都是static的方法呢？因为在Spring项目中new非基础类很不优雅（结合个推工具类理解）
@Value不能修饰静态变量，写法是@Value("${tx.sts.host}")
BeanUtils.copyProperties(villageDto, village)		//这是Spring的工具类
需要调用第三方功能，自己写一个service暴露服务，然后在服务里调用第三方接口，不要写成一个util类
账号密码等敏感信息，不要写死在代码里面，因为代码有可能被人反编译

12.8
RESTful风格主要是做权限管理这一块要用到的
有些市是没有区县的，这点在以后的项目中要注意

12.10
不要随便用forcePush，puhs不成功一个最常见的因素是有些文件没有commit（很可能是新建的那种），此时试试哪些没有commit就可以了
Lombok是一个及其有用的插件，@Getter和@Setter是基础功能，还提供了@EqualsAndHashCode，@ToString，@Slf4j，@Log4j这几个非常好用的功能
HttpURLConnection connection = (HttpURLConnection)base.openConnection();				//HttpURLConnection这个类经常用来做设置格式之类的处理
connection.setRequestProperty("Authorization","helloWorld");											//往Header里加参数										
connection.setRequestMethod(RequestMethod.POST.name());											//设置访问的方法
Spring一般在使用时的事务隔离级别选择ISOLATION_DEFAULT，跟随数据库的隔离级别就可以了，除非特殊情况（这种情况很少，出现的话也是DBA去处理）
注解一般都是使用在具体的实现类(比如@Transaction)，很少使用在接口上(除非一些专门针对接口的注解)，因为注解不会被继承（也就是使用interface-based proxy）的时候
注：JDK的代理是interface-based的，cglib的代理是class-based的；
Spring选择代理的原则是：如果bean实现了接口，那么会使用JDK代理；如果没有的实现接口则使用cglib代理；可以在配置文件中强制使用cglib代理
因为上述的原因（Spring选择代理的不确定性），所以注解不适合写在接口上，而是应该写在具体实现类上
日常的开发中经常要在某个Service调用其他Service，@Transactional的作用就体现在这个地方
REQUIRES_NEW：外面的事务挂起，里面起一个新事务，里面的事务发生异常，外面的事务会接收到异常（至于回不回滚就看外面的事务有没有处理了）
事务的传播机制在一个Service调用多个Service时需要慎重考虑的（后面的Service遇到异常回滚了，前面已执行完的Service哪些要跟着一起回滚，哪些不回滚）
C/S的C是指Client（QQ微信之类），B/S的B是指Brower（所有的服务器网站）
@Transactional只捕获RuntimeException(至于为什么，可能要进一步研究一下源码)，rollback = Exception.class
@Transactional有个value的属性，是用来指定事务管理器(DataSourceTransactionManager)的，一个系统里可能有多个事务管理器，因为可能有多个数据源(库)，不同的数据源(库)要使用不同的事务管理器
一个数据源（DataSource）对应一个数据库，它的作用就是隐藏了连接数据库的具体操作
不管写不写@Transactional，事务是肯定有的(InnoDB的特性，单条sql一个事务)，加上@Transactioal则事务的范围扩大(变成多条sql一个事务)
show (full) processlist		mysql查看死锁需要用到的命令

12.11
@RefreshScope使用时必须在springboot的配置文件中暴露refresh这个接口(spring boot actuator相关)，然后当配置文件修改了之后，调用/actuator/refresh就可以刷新配置文件(这个接口会返回配置文件哪些被修改了)
注：Spring2.0和Spring1.0对这个注解的使用方式略微有些不同，上面是针对Spring2.0的情况
@RefreshScope不能修饰final类
@ConfigurationProperties加在类上要和@Component配合使用，一般还会配置prefix
Math.random(）生成一个从0.0到1.0之间的数字，有概率出0.000000001这种前面几十个0的情况
UNIX时间戳的单位是秒！秒！秒！，java要获取这个时间戳用System.currentTimeMillis()/1000
腾讯的STS是Security Token Service(属于CAM的子模块)，COS是Cloud Object Storage(云对象存储)，CAM是Cloud Access Management(访问权限控制)，CVM是Cloud Virtual Machine(云服务器)
IDC是Internet Data Center，一个比较统称的说法
(Math.random()*9+1)*100000		生成6位随机数
SecretId是用来获取SecretKey的，SecretKey是真正用于生成密码的一个类似辅码的工具
String里面只可能出现双数的"\"，不可能出现单数

12.12
像腾讯api接口的host地址这些，可以选择写在配置文件中而不是写在public static final常量中，因为配置文件有接口可以实时读取，常量的话目前只有重启这条路
可变参数其实可以用一个Map去替代
HashMap内部对key是没有排序的(或者说我完全看不出来)，TreeMap会对key做升序排列，所有有特殊的需求可以用TreeMap(比如腾讯云的很多接口的参数需要按名字升序排序，此时用TreeMap处理就会方便很多)
字典序也就是ASCII码序(小写字母是比大写字母的值要大的)
File file = new File("src/main/resources/address.xml");		//项目里的相对路径，从src文件夹开始




























































