11.29
mysql免安装版如果执行的时候提示少了某个MSV之类的dll，去下载一个vcredist.exe安装
如果莫名其妙无法启动服务，那么去看看data是否创建了，如果创建了里面是不是有文件，这两种情况都会让mysql服务无法启动
角色权限：localhost代表只有本机可以连接上数据库，%表示所有机器都可以连上数据库
mysql5.7免安装版，在配置完之后会为root角色自动创建一个随机密码，这个密码在data文件夹里的xxx.err文件里(xxx是随机的，在文件里搜关键字temporary就可以找到密码所在的那一行)
然后在命令行用mysql -hlocalhost -uroot -p命令进入mysql把这个随机密码改掉（注意用-hlocalhost，不要用-h，不然有很大几率不成功）
POJO对象一般和数据库表的属性一一对应，DTO（数据传输对象）就是增加或删除某些列的POJO（假设现在POJO里有一个属性address，但是前端页面不需要显示address这个属性，那么可以传一个没有这个属性的DTO对象给前端）
记住：git和svn一样，都是需要安装的
从git上check下来的项目会看不见project视图，这时把项目里的.idea文件夹删除再重新打开就可以了

11.30
一般公司的项目肯定是会有maven私服的，一些通用模块会放到私服上去，deploy命令就是把代码上传到私服（install是把代码上传到本地仓库，多人共同开发项目一般都是用deploy的，毕竟代码要给别人使用）
nexus做代码仓库私服
通过groupId，ArtifactId和version可以确定一个maven项目，一般groupId的名字会以一些唯一性比较强的名词组成（比如公司域名反写），避免和他人重复
加盐：密码学的知识，系统随机往客户的密码上加一个值（salt值），salt值只有系统知道，然后再进行散列(比如MD5)；这样即使黑客知道了密码，由于salt值是不确定的，也很难盗号（这样撞库就没有用了）
sb.deleteCharAt(sb.length()-1)		//去掉最后一个字符

12.2
让debug，versionControl，maven这些窗口常驻的按钮再左下角那个小电脑处
maintainer比developer的权限还要大
APP不像PC端sessionId，所以登陆这方面处理和PC端不太一样
分布式sessionId一般必须借助redis实现，不过运用JWE(JWT)工具可以更加简单地实现这个功能
origin开头表示远程仓库，没有的表示本地仓库

12.3
容器存放的就是对象本身，而不是对象的拷贝，也就是说对象存放进容器之后，对象修改了，容器里的对象也会修改
clear()方法清空容器里的所有数据（所有存它的容器的数据都会跟着变），它和用"="重新给对象赋值的效果是不一样的，要根据业务需求使用
fastjson可以处理像Map，List这些转成json字符串的需求，非常方便
如果一个表的主键字段不是叫id，那么在@Table注解的时候要在注解里声明主键对应的字段
Ctrl+Shift+U	//将字符串快速大小写
install之后其他项目并不需要reimport

12.4
联表查询在分布式系统中的使用要慎重，因为你不知道哪天关联的那两张表就分开到不同的数据库里面了
在Controller里传递参数时有一个required的参数，如果时true那么你没传这个参数那么就不会进入对应的方法；如果是false你还是会进入对应的方法

12.5
mysql建索引的时候会锁表，在5.6版本之后对建索引时的锁表做了某些优化
对于可变参数的函数，可以直接传一个数组进去
Integer[] ids = new BigInteger[idList.size()];
idList.toArray(ids);												//List转数组
聚合服务要布多点系统
权限管理在网关那边处理，服务是无状态的(也就是请求来就处理，不挑食)

12.6
NIO简单来说就是一条线程处理多个连接
Controller调用Controller或自己旗下的Service，Service调用其他Serivce或自己旗下的Dao
Controller调用Controller有一个非常大的好处，就是参数和返回类型不需要匹配多个，只需要匹配其中一个就可以了
在Controller这一层处理一些简单的权限问题
优先使用Byte.valueOf(String)创建Byte对象而不是用new Byte；当然也可以用(byte)4

12.7
idea一个窗口中增加maven项目，在maven工具栏那里把对应项目的pom文件加进来就可以了，它会自动把项目引入（这对微服务项目尤其便利），而且版本工具能正常使用
删掉窗口中的项目，去项目设置里把那个模块去掉就行了（maven工具栏那里还会存在那个项目的pom文件，只要重启就不见了）
如果在maven中指定了私有仓库，那么在引入其他具有repositories的依赖时，可能会有问题，此时将idea的conf.xml指回默认的配置文件就可以了
工具类为什么都是static的方法呢？因为在Spring项目中new非基础类很不优雅（结合个推工具类理解）
@Value不能修饰静态变量，写法是@Value("${tx.sts.host}")
BeanUtils.copyProperties(villageDto, village)		//这是Spring的工具类
需要调用第三方功能，自己写一个service暴露服务，然后在服务里调用第三方接口，不要写成一个util类
账号密码等敏感信息，不要写死在代码里面，因为代码有可能被人反编译

12.8
RESTful风格主要是做权限管理这一块要用到的
有些市是没有区县的，这点在以后的项目中要注意

12.10
不要随便用forcePush，puhs不成功一个最常见的因素是有些文件没有commit（很可能是新建的那种），此时试试哪些没有commit就可以了
Lombok是一个及其有用的插件，@Getter和@Setter是基础功能，还提供了@EqualsAndHashCode，@ToString，@Slf4j，@Log4j这几个非常好用的功能
HttpURLConnection connection = (HttpURLConnection)base.openConnection();				//HttpURLConnection这个类经常用来做设置格式之类的处理
connection.setRequestProperty("Authorization","helloWorld");											//往Header里加参数										
connection.setRequestMethod(RequestMethod.POST.name());											//设置访问的方法
Spring一般在使用时的事务隔离级别选择ISOLATION_DEFAULT，跟随数据库的隔离级别就可以了，除非特殊情况（这种情况很少，出现的话也是DBA去处理）
注解一般都是使用在具体的实现类(比如@Transaction)，很少使用在接口上(除非一些专门针对接口的注解)，因为注解不会被继承（也就是使用interface-based proxy的时候注解可能不会生效）
注：JDK的代理是interface-based的，cglib的代理是class-based的；
Spring选择代理的原则是：如果bean实现了接口，那么会使用JDK代理；如果没有的实现接口则使用cglib代理；可以在配置文件中强制使用cglib代理
因为上述的原因（Spring选择代理的不确定性），所以注解不适合写在接口上，而是应该写在具体实现类上
日常的开发中经常要在某个Service调用其他Service，@Transactional的作用就体现在这个地方
REQUIRES_NEW：外面的事务挂起，里面起一个新事务，里面的事务发生异常，外面的事务会接收到异常（至于回不回滚就看外面的事务有没有处理了）
事务的传播机制在一个Service调用多个Service时需要慎重考虑的（后面的Service遇到异常回滚了，前面已执行完的Service哪些要跟着一起回滚，哪些不回滚）
C/S的C是指Client（QQ微信之类），B/S的B是指Brower（所有的服务器网站）
@Transactional只捕获RuntimeException(至于为什么，可能要进一步研究一下源码)，rollback = Exception.class
@Transactional有个value的属性，是用来指定事务管理器(DataSourceTransactionManager)的，一个系统里可能有多个事务管理器，因为可能有多个数据源(库)，不同的数据源(库)要使用不同的事务管理器
一个数据源（DataSource）对应一个数据库，它的作用就是隐藏了连接数据库的具体操作
不管写不写@Transactional，事务是肯定有的(InnoDB的特性，单条sql一个事务)，加上@Transactioal则事务的范围扩大(变成多条sql一个事务)
show (full) processlist		mysql查看死锁需要用到的命令

12.11
@RefreshScope使用时必须在springboot的配置文件中暴露refresh这个接口(spring boot actuator相关)，然后当配置文件修改了之后，调用/actuator/refresh就可以刷新配置文件(这个接口会返回配置文件哪些被修改了)
注：Spring2.0和Spring1.0对这个注解的使用方式略微有些不同，上面是针对Spring2.0的情况
@RefreshScope不能修饰final类
@ConfigurationProperties加在类上要和@Component配合使用，一般还会配置prefix
Math.random(）生成一个从0.0到1.0之间的数字，有概率出0.000000001这种前面几十个0的情况
UNIX时间戳的单位是秒！秒！秒！，java要获取这个时间戳用System.currentTimeMillis()/1000
腾讯的STS是Security Token Service(属于CAM的子模块)，COS是Cloud Object Storage(云对象存储)，CAM是Cloud Access Management(访问权限控制)，CVM是Cloud Virtual Machine(云服务器)
IDC是Internet Data Center，一个比较统称的说法
(Math.random()*9+1)*100000		生成6位随机数
SecretId是用来获取SecretKey的，SecretKey是真正用于生成密码的一个类似辅码的工具
String里面只可能出现双数的"\"，不可能出现单数

12.12
像腾讯api接口的host地址这些，可以选择写在配置文件中而不是写在public static final常量中，因为配置文件有接口可以实时读取，常量的话目前只有重启这条路
可变参数其实可以用一个Map去替代
HashMap内部对key是没有排序的(或者说我完全看不出来)，TreeMap会对key做升序排列，所有有特殊的需求可以用TreeMap(比如腾讯云的很多接口的参数需要按名字升序排序，此时用TreeMap处理就会方便很多)
字典序也就是ASCII码序(小写字母是比大写字母的值要大的)
File file = new File("src/main/resources/address.xml");		//项目里的相对路径，从src文件夹开始
secureCRT里面选择"快速连接"

12.13
腾讯云直播的时候，后台需要返回推流URL给主播APP，返回播放URL给观众APP
Long.toHexString(txTime).toUpperCase()			//将一个10进制数字改成16进制，记得要变大写
像腾讯云的接口，鉴权的主要手段就是：时间戳+SecretId+Signature，可以学习这种安全措施
JSONObject就是一个Map
"aaa".getBytes("UTF-8")		//使用getBytes随手跟字符编码，养成好习惯
用java的MD5加密之后出来的byte[]如果直接组成String有很大概率乱码，此时要做一下处理(byteArrayToHexString)

12.14
像管理员获取小区楼栋信息的接口，为什么要读取数据库获取管理员的小区所属，而不是直接在前端传个小区id过来，是因为获取了这个请求的话可以随便改小区id，这样就能看到权限之外的信息
像门禁端发过来的请求，传过来的参数都会验证是否准确，所以这时候别人乱传参数也不怕，因为肯定过不了验证这一关
总结：参数如果不经过验证（验证正确性而不是合法性），这样的参数越少越好
log.error("",e);			log.error("用户已注册，mobile:{}", mobile);			//这两种日志处理异常的方法最常见
gson是谷歌那么出的一个和json解析相关的类，是线程安全的(重点)
事务不推荐加在Controller层
Controller一般不会调用多个Service，因为这样做就没有事务控制了；但是在只有查询的情况下，是可以这样做的
Controller一般按业务分，一般可以这样做，基础的表都有一个对应的Controller，然后云直播，音视频这些做单独的Controller(这些没有对应的表但是会调用基础表的Service)；也就是基础+业务的类型

12.15
网关拦截请求的全过程：
检查请求Header里面是否带有"Authorization"
    -->有：检验Authorization是否合法(这一步用JWT处理)
         -->合法：请求继续往下走，并在Request里面存放一个User对象
         -->不合法：抛异常(身份校验失败)，前端自行处理
    -->没有：检查是否是登陆操作(请求是否含有"login"字段)
        -->是：请求继续往下走，进入登陆函数；登陆之后生成一个Authorization的值，以后前端的请求都要带上这个值
        -->不是：抛异常(你没登陆)，前端跳到登陆页面或者其他处理
总结：只有登陆请求网关会放它过去，其他请求都必须经过网关的校验
不同的网关程序是部署在不同的端口上的
开启80(HTTP端口)和443(HTTPS端口)必须经过ICP(Internet Content Provider，网络内容服务商)备案
在正常的使用中，nginx一般会监听80和443两个端口，然后根据实际业务需求，把请求转发到本机上的其他端口或者另外的服务器上的某个端口(也就是请求总是第一时间经过nginx，在不考虑硬件设备的情况下)
调用第三方服务出现异常要打印详细日志，不然出了问题就等着哭吧

12.17
一般在正式的项目中，会用openId替代userId返回给前台或者APP端，因为userId会暴露用户量；openId和userId的作用一样，都是可以唯一标识一个用户
用户密码的加密：假设密码为123456，salt值为helloWorld
	1）首先将密码123456进行MD5加密，变成e10adc3949ba59abbe56e057f20f883e
	2）将加密后的密码加上salt值再进行MD5加密，也就是e10adc3949ba59abbe56e057f20f883ehelloWorld进行加密，变成05279868b8fb3f65ee1d809376d72075
	3）这种加密算是比较规范的，有些网站只进行了第一步的加密
openid的生成也是经过上述步骤，就是基础改成mobile(或者用户id)+System.currentTimeMillis()
网关的一个作用是筛选哪些请求能够到达Controller，哪些不能，所以网关是决定不会涉及到业务逻辑的，一旦出现业务逻辑百分百是写错了的
网关的筛选，要根据不同请求的作用进行不同的筛选，比如有些接口是需要登陆的(比如查看个人中心)，那么网关鉴权登陆了没有；有些不需要登陆的(忘记密码，注册登录，CSDN看文章不需要登陆等等)，网关就直接放它过去了
以深空为例，访问路径里包含usercenter的，说明和个人中心有关，那么肯定是要校验登陆的；访问路径是user的，里面的接口是忘记密码，注册登陆这些，所以就不需要校验登陆了
网关的另一个作用是权限管理，正常项目都是有权限角色管理的，不同的角色有不同的接口的访问权限(比如某些管理员是没有删除的权限的，防止手贱)
服务是无状态的，但是Controller是有状态的，Controller一般是校验参数合法(校验参数是否为null，以及mobile长度是否是11位且符合手机的正则这些)在Controller里面做，也就是@Validated写在Controller里，不要写在Service里面
总结：网关验证权限(能否访问接口，双重意义上)，Controller校验参数合法性，Service什么都不校验
Json读J森，JSONObject.getXXX这些方法，如果获取不到会返回null(用屁股想一想都知道不可能返回其他东西或者抛异常，不然直接被拿去祭天了)

12.18
authorization是openId经过jwt加密后的产物，而openId又是MD5+salt加密后的产物，也就是双重加密
villageId = 41 and villageId in (35,45,78)	//这句话在业务逻辑中是很正确的，没有任何一条记录符合条件，说明此账号查询了他没有权限的village

12.19
house表里面需要查到villageName，常见的作法有join和字段冗余两种；join的话后期分库分表会有大麻烦，字段冗余则有数据同步的问题，要怎么选看取舍，在不确定后期会怎么分表的情况下还是用字段冗余，数据同步的问题，如果数据不重要那么就不同步了
跨域限制访问有两个地方：接口访问和dom的查询
跨域限制访问，是浏览器限制，也就是说用java写一个http请求去调用接口，是不会有什么跨域的问题的(接口的权限校验就是另外一回事了)
解决跨域就上nginx(接下来的事情就交给前端和运维了)
同源策略中的源指协议域名端口三者联合，只要这三个都一样就是同源

跨域未完待续---------------------------------------------------------------------------------华丽的分割线---------------------------------------------------------------------------------------------------------------------------------------------

List的contains方法作用不需要多说，这个方法对BigInteger也是有效的，说明BigInteger重写了equals方法
List.containsAll(Collection)这个方法见名知意，Collection里的元素List全都有就返回true，其他返回false
因为后台账号的管理员权限只涉及到小区这个层次，所以对查询来说，如果要查询的表里面有小区id，再查询的时候加个in语句就行；对增删改来说，如果增删改的表里面有小区id，那么前置必须检查此账号是否有小区的权限(这个操作可能在拦截器里做)
上面这种做法是不怎么正确的，很可能就搞出有状态的服务了

12.20
ramdom.nextInt(20)			//符合条件的有20个数字，从0到19
vo可以考虑公用，dto和service还是用户层和管理员层分开吧，便于管理

12.22
这一天的知识全部写到YNote里面了，为了不引起混淆把所有东西都删掉

12.23

























































